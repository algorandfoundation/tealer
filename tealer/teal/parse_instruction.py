from typing import Optional

from tealer.teal.instructions import (
    Err,
    Gtxn,
    Pragma,
    Int,
    Txna,
    Txn,
    Load,
    Store,
    Global,
    Sha512_256,
    Dup,
    Concat,
    Instruction,
    Label,
    Addr,
    Pop,
    Byte,
    ByteBase64,
    Btoi,
    Less,
    LessE,
    Greater,
    GreaterE,
    Mul,
    AppLocalGet,
    AppLocalPut,
    AppLocalGetEx,
    AppGlobalPut,
    AppGlobalGet,
    Balance,
    Return,
    BNZ,
    BZ,
    B,
    Eq,
    Neq,
    And,
    Or,
    Add,
    Div,
    Sub,
    Keccak256,
    Sha256,
    Ed25519verify,
    Modulo,
    Not,
    BitwiseAnd,
    BitwiseOr,
    BitwiseXor,
    BitwiseInvert,
    Itob,
    Dup2,
    AppGlobalGetEx,
    AppGlobalDel,
    AppOptedIn,
    AssetHoldingGet,
    AssetParamsGet,
    Mulw,
    Addw,
    Intcblock,
    Intc,
    Intc0,
    Intc1,
    Intc2,
    Intc3,
    Bytec,
    Bytec0,
    Bytec1,
    Bytec2,
    Bytec3,
    Arg,
    Arg0,
    Arg1,
    Arg2,
    Arg3,
    AppLocalDel,
)
from tealer.teal.parse_global_field import parse_global_field
from tealer.teal.parse_transaction_field import parse_transaction_field


def handle_gtnx(x: str) -> Gtxn:
    split = x.split(" ")
    idx = int(split[0])
    tx_field = parse_transaction_field(" ".join(split[1:]))
    return Gtxn(idx, tx_field)


# Order in the parser_rules is important
parser_rules = [
    ("#pragma version ", lambda x: Pragma(x)),
    ("err", lambda _x: Err()),
    ("int ", lambda x: Int(x)),
    ("txn ", lambda x: Txn(parse_transaction_field(x))),
    ("txna ", lambda x: Txna(parse_transaction_field(x))),
    ("gtxn ", lambda x: handle_gtnx(x)),
    ("load ", lambda x: Load(int(x))),
    ("store ", lambda x: Store(int(x))),
    ("sha256", lambda _x: Sha256()),
    ("sha512_256", lambda _x: Sha512_256()),
    ("keccak256", lambda _x: Keccak256()),
    ("ed25519verify", lambda _x: Ed25519verify()),
    ("global ", lambda x: Global(parse_global_field(x))),
    ("dup2", lambda _x: Dup2()),
    ("dup", lambda _x: Dup()),
    ("concat", lambda _x: Concat()),
    ("b ", lambda x: B(x)),
    ("bz ", lambda x: BZ(x)),
    ("bnz ", lambda x: BNZ(x)),
    ("return", lambda x: Return()),
    ("app_global_get_ex", lambda x: AppGlobalGetEx()),
    ("app_global_get", lambda x: AppGlobalGet()),
    ("app_global_put", lambda x: AppGlobalPut()),
    ("app_global_del", lambda x: AppGlobalDel()),
    ("app_local_get_ex", lambda x: AppLocalGetEx()),
    ("app_local_get", lambda x: AppLocalGet()),
    ("app_local_put", lambda x: AppLocalPut()),
    ("app_local_del", lambda x: AppLocalDel()),
    ("app_opted_in", lambda x: AppOptedIn()),
    ("balance", lambda x: Balance()),
    ("asset_holding_get", lambda x: AssetHoldingGet()),
    ("asset_params_get", lambda x: AssetParamsGet()),
    ("%", lambda x: Modulo()),
    ("!=", lambda x: Neq()),
    ("!", lambda x: Not()),
    ("==", lambda x: Eq()),
    ("&&", lambda x: And()),
    ("&", lambda x: BitwiseAnd()),
    ("||", lambda x: Or()),
    ("|", lambda x: BitwiseOr()),
    ("+", lambda x: Add()),
    ("-", lambda x: Sub()),
    ("/", lambda x: Div()),
    ("*", lambda x: Mul()),
    (">=", lambda x: GreaterE()),
    (">", lambda x: Greater()),
    ("<=", lambda x: LessE()),
    ("<", lambda x: Less()),
    ("^", lambda x: BitwiseXor()),
    ("~", lambda x: BitwiseInvert()),
    ("itob", lambda x: Itob()),
    ("btoi", lambda x: Btoi()),
    ("byte base64", lambda x: ByteBase64(x)),
    ("byte ", lambda x: Byte(x)),
    ("pop", lambda x: Pop()),
    ("addr ", lambda x: Addr(x)),
    ("mulw", lambda x: Mulw()),
    ("addw", lambda x: Addw()),
    ("intcblock", lambda x: Intcblock()),
    ("intc ", lambda x: Intc(x)),
    ("intc_0", lambda x: Intc0()),
    ("intc_1", lambda x: Intc1()),
    ("intc_2", lambda x: Intc2()),
    ("intc_3", lambda x: Intc3()),
    ("bytec ", lambda x: Bytec(x)),
    ("bytec_0", lambda x: Bytec0()),
    ("bytec_1", lambda x: Bytec1()),
    ("bytec_2", lambda x: Bytec2()),
    ("bytec_3", lambda x: Bytec3()),
    ("arg ", lambda x: Arg(x)),
    ("Arg_0", lambda x: Arg0()),
    ("Arg_1", lambda x: Arg1()),
    ("Arg_2", lambda x: Arg2()),
    ("Arg_3", lambda x: Arg3()),
]


def parse_line(line: str) -> Optional[Instruction]:
    if "//" in line:
        line = line[0 : line.find("//")]
    if ":" in line:
        return Label(line[0 : line.find(":")])
    for key, f in parser_rules:
        if line.startswith(key):
            return f(line[len(key) :])
    if line:
        print(f"Not found {line}")
        return None
    return None
